<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - glTF loader</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>
<style>

  #clear_data {
    position: absolute;
    right: 0px;
    top: 450px;
    width: 100px;
    height: 100px;
    opacity: 0.5;
  }

  #cavas {
    position: fixed;
    top: 0px;
    left: 0px;
  }
</style>

<body>
  <div id="info">
  </div>
  <script type='text/javascript' src='./Vconsole.js'></script>
  <script type="module">
    import * as THREE from './lib/three.module.js';
    import { OrbitControls } from './lib/OrbitControls.js';
    import { GLTFLoader } from './lib/GLTFLoader.js';
    import { RGBELoader } from './lib/RGBELoader.js';
    import { RoughnessMipmapper } from './lib/RoughnessMipmapper.js';
    import {OBJLoader2} from './lib/OBJLoader2.js';
    import { EffectComposer } from './lib/postprocessing/EffectComposer.js';
		import { RenderPass } from './lib/postprocessing/RenderPass.js';
		import { ShaderPass } from './lib/postprocessing/ShaderPass.js';
    import { GUI } from './lib/dat.gui.module.js';
    import {backMaterial_frag, backMaterial_vert, frontMaterial_frag, frontMaterial_vert} from './shader.js'

    console.log(THREE.REVISION)
    console.log(`THREE.RGBAFormat:${THREE.RGBAFormat}`);
    console.log(`THREE.RGBFormat:${THREE.RGBFormat}`);
    console.log(`THREE.UnsignedByteType:${THREE.UnsignedByteType}`);

    var container, controls;
    var roughnessMipmapper;
    var camera, scene, renderer;
    var composer;
    var backMaterial, frontMaterial;
    var objBack, objFront;
    var clock = new THREE.Clock();
    var vConsole = new VConsole();
    var gui = new GUI();


    var controls = new function () {
      this.Color = [1, 1, 1]; // RGB array
      this.ReflectionStrength = 0.0;
      this.EnvironmentLight = 1.0;
      this.Emission = 1.0;
    };
    gui.addColor(controls, 'Color').onChange((value)=> {
      console.log(value);
      backMaterial.uniforms.Color.value = new THREE.Vector3(value[0] / 255, value[1]/ 255, value[2]/ 255);
      frontMaterial.uniforms.Color.value = new THREE.Vector3(value[0] / 255, value[1]/ 255, value[2]/ 255);
    });
    gui.add(controls, 'ReflectionStrength', 0.0, 2.0).onChange((value) => {
      frontMaterial.uniforms.ReflectionStrength.value = value;
    });
    gui.add(controls, 'EnvironmentLight', 0.0, 2.0).onChange((value) => {
      backMaterial.uniforms.EnvironmentLight.value = value;
      frontMaterial.uniforms.EnvironmentLight.value = value;
    });
    gui.add(controls, 'Emission', 0.0, 2.0).onChange((value) => {
      backMaterial.uniforms.Emission.value = value;
      frontMaterial.uniforms.Emission.value = value;
    });




    console.log('Hello world');
    init();
   
    function init(useWork) {
      container = document.createElement('div');
      document.body.appendChild(container);
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 200);
      camera.position.set(- 1.8, 0.6, 2.7);
      scene = new THREE.Scene();
      // scene.background = new THREE.Color(0xffffff);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.debug.checkShaderErrors = false;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      //renderer.toneMapping = THREE.ACESFilmicToneMapping;
      //renderer.toneMappingExposure = 0.35;
      renderer.outputEncoding = THREE.sRGBEncoding;
      
     
      container.appendChild(renderer.domElement);

      var pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();
      controls = new OrbitControls(camera, renderer.domElement);
      controls.minDistance = 0.01;
      controls.maxDistance = 100;
      controls.target.set(0, 0, 0);
      controls.update();
      window.addEventListener('resize', onWindowResize, false);
      var cubeTexture = new THREE.CubeTextureLoader().setPath('cube/skyboxsun25deg/')
            .load(
                [
                    'px.jpg',
                    'nx.jpg',
                    'py.jpg',
                    'ny.jpg',
                    'pz.jpg',
                    'nz.jpg'
                ]
            );
      cubeTexture.mapping = THREE.CubeRefractionMapping;


      var refractTexture = new THREE.CubeTextureLoader().setPath('cube/12/')
            .load(
                [
                    '1.jpg',
                    '1.jpg',
                    '1.jpg',
                    '1.jpg',
                    '1.jpg',
                    '1.jpg'
                ]
            );
            refractTexture.mapping = THREE.CubeRefractionMapping;
            console.log(refractTexture);


      //load diamond
      var loader = new OBJLoader2();
      loader.load('./model/meshes/RoundCut.obj',(obj) => {
        objBack = obj.children[0];
        new RGBELoader().setDataType(THREE.UnsignedByteType).
        setPath('./model/hdr/').load('royal_esplanade_1k.hdr', (tex)=>{
        console.log(tex);
        var envMap2 = pmremGenerator.fromEquirectangular(tex).texture;
        tex.mapping = THREE.CubeRefractionMapping;
        scene.background =  cubeTexture;
        scene.environment = cubeTexture
        backMaterial = new THREE.ShaderMaterial({
          vertexShader : backMaterial_vert,
          fragmentShader: backMaterial_frag,
          side: THREE.BackSide,
          transparent: true,
          depthWrite: false,
          uniforms:{
            "tCube": { type: "t", value: cubeTexture },
            "RefractTex": { type: "t", value: refractTexture },
            "cameraWorldPos":{value:[0, 0, 0]},
            "modelMatrix":{value:new THREE.Matrix4()},
            "Color":{value: new THREE.Vector3(1, 1, 1)},
            "EnvironmentLight":{value: 1.0},
            "Emission":{value: 1.0},
          },
        });

        console.log(backMaterial);
        objBack.material = backMaterial;   // cubeMaterial1;
        objBack.material.needsUpdate = true;
        scene.add(objBack);
        console.log(objBack);

        objFront = objBack.clone(true);

        frontMaterial = new THREE.ShaderMaterial({
          vertexShader : frontMaterial_vert,
         fragmentShader: frontMaterial_frag,
          side: THREE.FrontSide,
          transparent: true,
          depthWrite: false,
          uniforms:{
            "tCube": { type: "t", value: cubeTexture },
            "cameraWorldPos":{value:[0, 0, 0]},
            "modelMatrix":{value:new THREE.Matrix4()},
            "Color":{value: new THREE.Vector3(1, 1, 1)},
            "EnvironmentLight":{value: 1.0},
            "Emission":{value: 1.0},
            "ReflectionStrength": {value: 0.5},
            "RefractTex": { type: "t", value: refractTexture },
          },
        });
        objFront.material = frontMaterial;   // cubeMaterial1;
        objFront.material.needsUpdate = true;
        scene.add(objFront);

        animate();
        document.onkeydown= (event) => {
          if (event.keyCode == 65) {
            
            objBack.rotation.x += 0.04
            objFront.rotation.x += 0.04
          }
        };

      } );


      },null, (err) => {
        console.log(err);
      });




      composer = new EffectComposer( renderer );

     
        

      // var cubeMaterial2 = new THREE.MeshPhongMaterial({color: 0xccddff, 
      //     envMap:cubeTexture, refractionRatio:0.98, reflectivity:0.9});

      //   var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      //   var cube = new THREE.Mesh(geometry, cubeMaterial2);
      //   scene.add(cube);

      
    }

    function animate() {
      requestAnimationFrame(animate);
      //console.log(backMaterial);
      

      const mat = new THREE.Matrix4();
      const modlePos = new THREE.Vector3();
      modlePos.copy(camera.position);
      modlePos.applyMatrix4(mat.getInverse(objBack.matrix));
      backMaterial.uniforms.cameraWorldPos.value[0] = modlePos.x;
      backMaterial.uniforms.cameraWorldPos.value[1] = modlePos.y;
      backMaterial.uniforms.cameraWorldPos.value[2] = modlePos.z;
      backMaterial.uniforms.modelMatrix.value.copy(objBack.matrix);


      frontMaterial.uniforms.cameraWorldPos.value[0] = modlePos.x;
      frontMaterial.uniforms.cameraWorldPos.value[1] = modlePos.y;
      frontMaterial.uniforms.cameraWorldPos.value[2] = modlePos.z;


      //objFront.rotation.x += 0.04;
      //objBack.rotation.x +=  0.04;
      render();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    }

    function render() {
      renderer.render(scene, camera);
    }

  </script>
</body>

</html>