<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - glTF loader</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>
<style>

  #clear_data {
    position: absolute;
    right: 0px;
    top: 450px;
    width: 100px;
    height: 100px;
    opacity: 0.5;
  }

  #cavas {
    position: fixed;
    top: 0px;
    left: 0px;
  }
</style>

<body>
  <div id="info">
  </div>
  <script id="vertexShader" type="x-shader1/x-vertex1">
    varying vec3 uv2;
    uniform float cameraWorldPos[3];
    vec3 refract2(const in vec3 i, const in vec3 n, const in float eta)
    {
      float cosi = dot(i * -1.0, n);
      float cost2 = 1.0 - eta * eta * (1.0 - cosi * cosi);
      vec3 t = eta * i + n * (eta * cosi - sqrt(cost2));
      if (cost2 > 0.0) {
        return t;
      } else {
        return t * -1.0;
      }
      //return t * (vec3)(cost2 > 0.0);
    }
    void main() {
      vec3 vNormal = normal.xyz;
      vec3 vModlePosition = position.xyz;
      vec3 vertexViewDir = vec3(cameraWorldPos[0] - vModlePosition.x, cameraWorldPos[1] - vModlePosition.y, cameraWorldPos[2] - vModlePosition.z);
      vertexViewDir = vertexViewDir * -1.0;
      vertexViewDir = normalize(vertexViewDir);
      uv2 = 2.0 * vNormal - normalize(vertexViewDir);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
 </script>
 <script id="fragmentShader" type="x-shader/x-fragment">
    
    vec3 refract2(const in vec3 i, const in vec3 n, const in float eta)
    {
      float cosi = dot(i * -1.0, n);
      float cost2 = 1.0 - eta * eta * (1.0 - cosi * cosi);
      vec3 t = eta * i + n * (eta * cosi - sqrt(cost2));
      if (cost2 > 0.0) {
        return t;
      } else {
        return t * -1.0;
      }
      //return t * (vec3)(cost2 > 0.0);
    }
    
    uniform samplerCube tCube;
    uniform vec3 Color;
    uniform float EnvironmentLight;
    uniform float Emission;
    varying vec3 uv2;
    void main() {
        vec3 refraction = textureCube(tCube, uv2).rgb * Color.xyz;
        vec4 reflection = textureCube(tCube, uv2);
        vec3 multiplier = reflection.xyz * EnvironmentLight + vec3(Emission, Emission, Emission);
        gl_FragColor = vec4(refraction.xyz *multiplier.xyz , 0.5);
    }
  </script>




  <script id="vertexShader_front" type="x-shader1/x-vertex1">
    varying vec3 uv2;
    varying float fresnel;
    uniform float cameraWorldPos[3];
    void main() {
      vec3 vNormal = normal.xyz;
      vec3 vModlePosition = position.xyz;
      vec3 vertexViewDir = vec3(cameraWorldPos[0] - vModlePosition.x, cameraWorldPos[1] - vModlePosition.y, cameraWorldPos[2] - vModlePosition.z);
      vertexViewDir = vertexViewDir * -1.0;
      vertexViewDir = normalize(vertexViewDir);
      uv2 = 2.0 * vNormal - normalize(vertexViewDir);
      fresnel = 1.0 - dot(vNormal, vertexViewDir);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
 </script>
 <script id="fragmentShader_front" type="x-shader/x-fragment">
    varying vec3 uv2;
    varying float fresnel;
    uniform samplerCube tCube;
    uniform vec3 Color;
    uniform float EnvironmentLight;
    uniform float Emission;
    uniform float ReflectionStrength;
   
    void main() {
       vec3 refraction = textureCube(tCube, uv2).xyz * Color.xyz;
       vec4 reflection = textureCube(tCube, uv2);
       vec3 reflection2 = reflection.xyz * ReflectionStrength * fresnel;
       vec3 multiplier = reflection.xyz * EnvironmentLight + vec3(Emission, Emission, Emission);
       gl_FragColor =  vec4(reflection2 + refraction.xyz * multiplier, 0.5);
    }
  </script>




  <script type='text/javascript' src='./Vconsole.js'></script>
  <script type="module">
    import * as THREE from './lib/three.module.js';
    import { OrbitControls } from './lib/OrbitControls.js';
    import { GLTFLoader } from './lib/GLTFLoader.js';
    import { RGBELoader } from './lib/RGBELoader.js';
    import { RoughnessMipmapper } from './lib/RoughnessMipmapper.js';
    import {OBJLoader2} from './lib/OBJLoader2.js';
    import { EffectComposer } from './lib/postprocessing/EffectComposer.js';
		import { RenderPass } from './lib/postprocessing/RenderPass.js';
		import { ShaderPass } from './lib/postprocessing/ShaderPass.js';
    import { GUI } from './lib/dat.gui.module.js';

    console.log(THREE.REVISION)
    console.log(`THREE.RGBAFormat:${THREE.RGBAFormat}`);
    console.log(`THREE.RGBFormat:${THREE.RGBFormat}`);
    console.log(`THREE.UnsignedByteType:${THREE.UnsignedByteType}`);

    var container, controls;
    var roughnessMipmapper;
    var camera, scene, renderer;
    var composer;
    var backMaterial, frontMaterial;
    var objBack, objFront;
    var clock = new THREE.Clock();
    var vConsole = new VConsole();
    var gui = new GUI();


    var controls = new function () {
      this.Color = [0, 128, 255]; // RGB array
      this.ReflectionStrength = 0.02;
      this.EnvironmentLight = 1.0;
      this.Emission = 1.0;
    };
    gui.addColor(controls, 'Color').onChange((value)=> {
      console.log(value);
      backMaterial.uniforms.Color.value = new THREE.Vector3(value[0] / 255, value[1]/ 255, value[2]/ 255);
      frontMaterial.uniforms.Color.value = new THREE.Vector3(value[0] / 255, value[1]/ 255, value[2]/ 255);
    });
    gui.add(controls, 'ReflectionStrength', 0.0, 2.0).onChange((value) => {
      frontMaterial.uniforms.ReflectionStrength.value = value;
    });
    gui.add(controls, 'EnvironmentLight', 0.0, 2.0).onChange((value) => {
      backMaterial.uniforms.EnvironmentLight.value = value;
      frontMaterial.uniforms.EnvironmentLight.value = value;
    });
    gui.add(controls, 'Emission', 0.0, 2.0).onChange((value) => {
      backMaterial.uniforms.Emission.value = value;
      frontMaterial.uniforms.Emission.value = value;
    });




    console.log('Hello world');
    init();
   
    function init(useWork) {
      container = document.createElement('div');
      document.body.appendChild(container);
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 200);
      camera.position.set(- 1.8, 0.6, 2.7);
      scene = new THREE.Scene();
      // scene.background = new THREE.Color(0xffffff);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.debug.checkShaderErrors = false;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      //renderer.toneMapping = THREE.ACESFilmicToneMapping;
      //renderer.toneMappingExposure = 0.35;
      renderer.outputEncoding = THREE.sRGBEncoding;
      
     
      container.appendChild(renderer.domElement);

      var pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();
      controls = new OrbitControls(camera, renderer.domElement);
      controls.minDistance = 0.01;
      controls.maxDistance = 100;
      controls.target.set(0, 0, 0);
      controls.update();
      window.addEventListener('resize', onWindowResize, false);

      //增加环境光
      var directionalLight = new THREE.DirectionalLight( 0xffffff, 2 );
      // directionalLight.castShadow = true;
      // renderer.shadowMap.enabled = true;
      scene.add( directionalLight ); 

      // scene.add(new THREE.AmbientLight(0x0c0c0c));
      // var spotLight1 = new THREE.SpotLight(0xffffff);
      // spotLight1.position.set(-400, -400, -400);
      // var spotLight2 = new THREE.SpotLight(0xffffff);
      // spotLight2.position.set(400, 400, 400);
      // scene.add(spotLight1);
      // scene.add(spotLight2);

      var cubeTexture = new THREE.CubeTextureLoader().setPath('cube/skyboxsun25deg/')
            .load(
                [
                    'px.jpg',
                    'nx.jpg',
                    'py.jpg',
                    'ny.jpg',
                    'pz.jpg',
                    'nz.jpg'
                ]
            );
      cubeTexture.mapping = THREE.CubeRefractionMapping;


      //load diamond
      var loader = new OBJLoader2();
      loader.load('./model/meshes/RoundCut.obj',(obj) => {
        objBack = obj.children[0];
        new RGBELoader().setDataType(THREE.UnsignedByteType).
        setPath('./model/hdr/').load('royal_esplanade_1k.hdr', (tex)=>{
        console.log(tex);
        var envMap2 = pmremGenerator.fromEquirectangular(tex).texture;
        tex.mapping = THREE.CubeRefractionMapping;
        scene.background =  cubeTexture;
        scene.environment = cubeTexture
        backMaterial = new THREE.ShaderMaterial({
          vertexShader : document.getElementById('vertexShader').textContent,
          fragmentShader: document.getElementById('fragmentShader').textContent,
          side: THREE.BackSide,
          transparent: true,
          depthWrite: false,
          uniforms:{
            "tCube": { type: "t", value: cubeTexture },
            "cameraWorldPos":{value:[0, 0, 0]},
            "modelMatrix":{value:new THREE.Matrix4()},
            "Color":{value: new THREE.Vector3()},
            "EnvironmentLight":{value: 0.0},
            "Emission":{value: 0.0},
          },
        });

        console.log(backMaterial);
        objBack.material = backMaterial;   // cubeMaterial1;
        objBack.material.needsUpdate = true;
        scene.add(objBack);
        console.log(objBack);

        objFront = objBack.clone(true);

        frontMaterial = new THREE.ShaderMaterial({
          vertexShader : document.getElementById('vertexShader_front').textContent,
          fragmentShader: document.getElementById('fragmentShader_front').textContent,
          side: THREE.FrontSide,
          transparent: true,
          depthWrite: false,
          uniforms:{
            "tCube": { type: "t", value: cubeTexture },
            "cameraWorldPos":{value:[0, 0, 0]},
            "modelMatrix":{value:new THREE.Matrix4()},
            "Color":{value: new THREE.Vector3()},
            "EnvironmentLight":{value: 0.0},
            "Emission":{value: 0.0},
            "ReflectionStrength": {value: 0.0}
          },
        });
        objFront.material = frontMaterial;   // cubeMaterial1;
        objFront.material.needsUpdate = true;
        scene.add(objFront);

        animate();




        // var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        // var cube = new THREE.Mesh(geometry, cubeMaterial1);
        // scene.add(cube);
        // tex.dispose();
        // pmremGenerator.dispose();

        document.onkeydown= (event) => {
          if (event.keyCode == 65) {
            
            objBack.rotation.x += 0.04
          }
        };

      } );


      },null, (err) => {
        console.log(err);
      });




      composer = new EffectComposer( renderer );

     
        

      // var cubeMaterial2 = new THREE.MeshPhongMaterial({color: 0xccddff, 
      //     envMap:cubeTexture, refractionRatio:0.98, reflectivity:0.9});

      //   var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      //   var cube = new THREE.Mesh(geometry, cubeMaterial2);
      //   scene.add(cube);

      
    }

    function animate() {
      requestAnimationFrame(animate);
      //console.log(backMaterial);
      

      const mat = new THREE.Matrix4();
      const modlePos = new THREE.Vector3();
      modlePos.copy(camera.position);
      modlePos.applyMatrix4(mat.getInverse(objBack.matrix));
      backMaterial.uniforms.cameraWorldPos.value[0] = modlePos.x;
      backMaterial.uniforms.cameraWorldPos.value[1] = modlePos.y;
      backMaterial.uniforms.cameraWorldPos.value[2] = modlePos.z;
      backMaterial.uniforms.modelMatrix.value.copy(objBack.matrix);


      frontMaterial.uniforms.cameraWorldPos.value[0] = modlePos.x;
      frontMaterial.uniforms.cameraWorldPos.value[1] = modlePos.y;
      frontMaterial.uniforms.cameraWorldPos.value[2] = modlePos.z;


      //objFront.rotation.x += 0.04;
      //objBack.rotation.x +=  0.04;
      render();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    }

    function render() {
      renderer.render(scene, camera);
    }

  </script>
</body>

</html>