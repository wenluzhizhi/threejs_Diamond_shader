<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - glTF loader</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>
<style>
  #clear_data {
    position: absolute;
    right: 0px;
    top: 450px;
    width: 100px;
    height: 100px;
    opacity: 0.5;
  }

  #cavas {
    position: fixed;
    top: 0px;
    left: 0px;
  }
</style>

<body>
  <div id="info">
  </div>
  <script type='text/javascript' src='./Vconsole.js'></script>
  <script type="module">
    import * as THREE from './lib/three.module.js';
    import { OrbitControls } from './lib/OrbitControls.js';
    import { GLTFLoader } from './lib/GLTFLoader.js';
    import { RGBELoader } from './lib/RGBELoader.js';
    import { RoughnessMipmapper } from './lib/RoughnessMipmapper.js';
    import { OBJLoader2 } from './lib/OBJLoader2.js';
    import { EffectComposer } from './lib/postprocessing/EffectComposer.js';
    import { RenderPass } from './lib/postprocessing/RenderPass.js';
    import { ShaderPass } from './lib/postprocessing/ShaderPass.js';
    import { UnrealBloomPass } from './lib/postprocessing/UnrealBloomPass.js';
    import { GUI } from './lib/dat.gui.module.js';
    import { getBackMaterial, getFrontMaterial } from './shader.js'

    console.log(THREE.REVISION)
    console.log(`THREE.RGBAFormat:${THREE.RGBAFormat}`);
    console.log(`THREE.RGBFormat:${THREE.RGBFormat}`);
    console.log(`THREE.UnsignedByteType:${THREE.UnsignedByteType}`);

    var container, controls, composer, bloomPass;
    var roughnessMipmapper;
    var camera, scene, renderer;
    var composer;
    var frontModel, backModel, zhihuanModel;
    var backMaterial, frontMaterial;
    var models = [];
    var clock = new THREE.Clock();
    var vConsole = new VConsole();


    var gui = new GUI();
   

    
    var params = {
        exposure: 1.1,
        bloomStrength: 0.8,
        bloomThreshold: 0.6,
        bloomRadius: 0.182
      };
     
    function AddGUI(params) {
      
      var controls ={
          Color : [1, 1, 1], // RGB array
          BackReflectionStrength : 1.0,
          BackRefractionStrength : 1.0,
          EnvironmentLight : 0.4,
          Emission : 0.19,
          backAlpha : 0.5,
          frontAlpha : 0.5,
          FrontReflectionStrength:1.0,
          FrontRefractionStrength:1.0,
          FrontEmissionStrength:1.0,
          showZhihuan: true,
      };
      
      

      gui.addColor(controls, 'Color').onChange((value) => {
        setModelUniformsC3("Color", value);
      });
      gui.add(controls, 'FrontReflectionStrength', 0.0, 5.0).onChange((value) => {
        frontModel.material.uniforms.FrontReflectionStrength.value = value;
      });
      gui.add(controls, 'FrontRefractionStrength', 0.0, 50.0).onChange((value) => {
        frontModel.material.uniforms.FrontRefractionStrength.value = value;
      });
      gui.add(controls, 'FrontEmissionStrength', 0.0, 5.0).onChange((value) => {
        frontModel.material.uniforms.FrontEmissionStrength.value = value;
      });
      gui.add(controls, 'frontAlpha', 0.0, 1.0).onChange((value) => {
        frontModel.material.uniforms.frontAlpha.value = value;
      });


      gui.add(controls, 'BackReflectionStrength', 0.0, 2.0).onChange((value) => {
        backModel.material.uniforms.BackReflectionStrength.value = value;
      });
      gui.add(controls, 'BackRefractionStrength', 0.0, 2.0).onChange((value) => {
        backModel.material.uniforms.BackRefractionStrength.value = value;
      });
      gui.add(controls, 'backAlpha', 0.0, 1.0).onChange((value) => {
        backModel.material.uniforms.backAlpha.value = value;
      });


      gui.add(params, 'exposure', 0.1, 2).onChange(function (value) {
        renderer.toneMappingExposure = Math.pow(value, 4.0);
      });

      gui.add(params, 'bloomThreshold', 0.0, 1.0).onChange(function (value) {
        bloomPass.threshold = (value);
      });

      gui.add(params, 'bloomStrength', 0.0, 10.0).onChange(function (value) {

        bloomPass.strength = value;

      });

      gui.add(params, 'bloomRadius', 0.0, 1.0).onChange(function (value) {

        bloomPass.radius = (value);

      });
      gui.add(controls, 'showZhihuan').onChange(function (value) {

        zhihuanModel.visible = value;

      });

    }


    function loadCubeMap(url) {
      return new Promise((resolve, reject) => {
        const loader = new THREE.CubeTextureLoader();
        loader.setPath(url);
        const tex = loader.load(['px.jpg','nx.jpg','py.jpg','ny.jpg','pz.jpg','nz.jpg'],(cubeTexture) => {
          resolve(cubeTexture);
        });
      });
    }

    function loadGlb(url) {
      return new Promise((resolve, reject) => {
        var loader = new GLTFLoader();
        loader.load(url, (glb) => {
          console.log(glb);
          resolve(glb.scene);
        });
      });
    }

    function processModel(model, cubeTexture, refractTexture) {
      console.log('-----------------');
      console.log(cubeTexture);
      console.log(refractTexture);
      backModel = model.getObjectByName("zuanshi");
      frontModel = backModel.clone(true);
      frontModel.name = "front_zuanshi";
      backModel.parent.add(frontModel);
      backModel.material = getBackMaterial(THREE, cubeTexture, refractTexture);
      console.log(frontModel);
      frontModel.material = getFrontMaterial(THREE, cubeTexture, refractTexture);

      zhihuanModel = model.getObjectByName("zhihuan");
    }

    init();
    AddGUI(params);

    async function init() {
      container = document.createElement('div');
      document.body.appendChild(container);
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 200);
      camera.position.set(0, 0, 0.5);
      scene = new THREE.Scene();
      // scene.background = new THREE.Color(0xffffff);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.debug.checkShaderErrors = false;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1;
      renderer.outputEncoding = THREE.sRGBEncoding;
      container.appendChild(renderer.domElement);
      var pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();
      controls = new OrbitControls(camera, renderer.domElement);
      controls.minDistance = 0.01;
      controls.maxDistance = 100;
      controls.target.set(0, 0, 0);
      controls.update();
      window.addEventListener('resize', onWindowResize, false);
      const cubeTexture = await loadCubeMap('model/jiezhi/');
      const refractTexture = await loadCubeMap('cube/12/1/');


      const model = await loadGlb('model/jiezhi/jiezhi.glb');
      scene.add(model);
      processModel(model, cubeTexture, refractTexture );
      console.log(model);

      scene.environment = cubeTexture;
      //scene.background = cubeTexture;

      const renderScene = new RenderPass(scene, camera);
      bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      bloomPass.threshold = params.bloomThreshold;
      bloomPass.strength = params.bloomStrength;
      bloomPass.radius = params.bloomRadius;

      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);
      console.log(composer);

      animate();
    }


    

    function setModelUniformsV3 (param, v3) {
      frontModel.material.uniforms[param].value[0] = v3.x;
      frontModel.material.uniforms[param].value[1] = v3.y;
      frontModel.material.uniforms[param].value[2] = v3.z;
      backModel.material.uniforms[param].value[0] = v3.x;
      backModel.material.uniforms[param].value[1] = v3.y;
      backModel.material.uniforms[param].value[2] = v3.z;
   }

    function setModelUniformsV1(param, v1) {
      frontModel.material.uniforms[param].value = v1;
      backModel.material.uniforms[param].value = v1;
    }

    function setModelUniformsC3(param, value) {
      
      frontModel.material.uniforms[param].value = new THREE.Vector3(value[0] / 255, value[1] / 255, value[2] / 255);
      backModel.material.uniforms[param].value = new THREE.Vector3(value[0] / 255, value[1] / 255, value[2] / 255);
      
    }


    function animate() {
      requestAnimationFrame(animate);
      //console.log(backMaterial);
      let mat = new THREE.Matrix4();
      let modlePos = new THREE.Vector3();
      modlePos.copy(camera.position);
      modlePos.applyMatrix4(mat.getInverse(backModel.matrixWorld));
      setModelUniformsV3("cameraWorldPos", modlePos);
      render();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    }

    function render() {
      composer.render();
      //renderer.render(scene, camera);
    }

  </script>
</body>

</html>