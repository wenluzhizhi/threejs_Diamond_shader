<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - glTF loader</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>
<style>
  #clear_data {
    position: absolute;
    right: 0px;
    top: 450px;
    width: 100px;
    height: 100px;
    opacity: 0.5;
  }

  #cavas {
    position: fixed;
    top: 0px;
    left: 0px;
  }
</style>

<body>
  <div id="info">
  </div>
  <script type="x-shader/x-vertex" id="vertexshader">

    varying vec2 vUv;

    void main() {

      vUv = uv;

      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  </script>

  <script type="x-shader/x-fragment" id="fragmentshader">

    uniform sampler2D baseTexture;
    uniform sampler2D bloomTexture;

    varying vec2 vUv;

    vec4 getTexture( sampler2D texelToLinearTexture ) {

      return mapTexelToLinear( texture2D( texelToLinearTexture , vUv ) );

    }

    void main() {
       
      vec4 v1 =  getTexture( baseTexture );
      vec4 v2 = vec4( 1.0 ) * getTexture( bloomTexture );
      gl_FragColor = v1 + v2;
    }

  </script>

  <script type='text/javascript' src='./Vconsole.js'></script>
  <script type= 'text/javascript' src='lib/EquirectangularToCubemap.js'></script>
  <script type="module">
    import * as THREE from './lib/three.module.js';
    import { OrbitControls } from './lib/OrbitControls.js';
    import { GLTFLoader } from './lib/GLTFLoader.js';
    import { RGBELoader } from './lib/RGBELoader.js';
    import { RoughnessMipmapper } from './lib/RoughnessMipmapper.js';
    import { OBJLoader2 } from './lib/OBJLoader2.js';
    import { EffectComposer } from './lib/postprocessing/EffectComposer.js';
    import { RenderPass } from './lib/postprocessing/RenderPass.js';
    import { ShaderPass } from './lib/postprocessing/ShaderPass.js';
    import { UnrealBloomPass } from './lib/postprocessing/UnrealBloomPass.js';
    import { GUI } from './lib/dat.gui.module.js';
    import { getBackMaterial, getFrontMaterial } from './shader.js'

    console.log(THREE.REVISION)
    console.log(`THREE.RGBAFormat:${THREE.RGBAFormat}`);
    console.log(`THREE.RGBFormat:${THREE.RGBFormat}`);
    console.log(`THREE.UnsignedByteType:${THREE.UnsignedByteType}`);

    var container, controls, composer, bloomPass, renderScene, renderScene2, finalComposer;
    var roughnessMipmapper;
    var camera, scene, renderer;
    var composer;
    var frontModel, backModel, zhihuanModel;
    var backMaterial, frontMaterial;
    var models = [];
    var clock = new THREE.Clock();
    var vConsole = new VConsole();
    var materials = {};
    var NORMAL_SCENE = 0, BLOOM_SCENE = 1;
    var bloomLayer = new THREE.Layers();
    bloomLayer.set( BLOOM_SCENE );
    var darkMaterial = new THREE.MeshBasicMaterial( { color: "black" } );

    var gui = new GUI();
    var params = {
      exposure: 1.1,
      bloomStrength: 0.8,
      bloomThreshold: 0.6,
      bloomRadius: 0.182
    };

    function AddGUI(params) {

      var controls = {
        Color: [1, 1, 1], // RGB array
        BackReflectionStrength: 1.0,
        BackRefractionStrength: 1.0,
        EnvironmentLight: 0.4,
        Emission: 0.19,
        backAlpha: 0.5,
        frontAlpha: 0.5,
        FrontReflectionStrength: 1.0,
        FrontRefractionStrength: 1.0,
        FrontEmissionStrength: 1.0,
        showZhihuan: true,
      };



      gui.addColor(controls, 'Color').onChange((value) => {
        setModelUniformsC3("Color", value);
      });
      gui.add(controls, 'FrontReflectionStrength', 0.0, 5.0).onChange((value) => {
        frontModel.material.uniforms.FrontReflectionStrength.value = value;
      });
      gui.add(controls, 'FrontRefractionStrength', 0.0, 50.0).onChange((value) => {
        frontModel.material.uniforms.FrontRefractionStrength.value = value;
      });
      gui.add(controls, 'FrontEmissionStrength', 0.0, 5.0).onChange((value) => {
        frontModel.material.uniforms.FrontEmissionStrength.value = value;
      });
      gui.add(controls, 'frontAlpha', 0.0, 1.0).onChange((value) => {
        frontModel.material.uniforms.frontAlpha.value = value;
      });


      gui.add(controls, 'BackReflectionStrength', 0.0, 2.0).onChange((value) => {
        backModel.material.uniforms.BackReflectionStrength.value = value;
      });
      gui.add(controls, 'BackRefractionStrength', 0.0, 2.0).onChange((value) => {
        backModel.material.uniforms.BackRefractionStrength.value = value;
      });
      gui.add(controls, 'backAlpha', 0.0, 1.0).onChange((value) => {
        backModel.material.uniforms.backAlpha.value = value;
      });


      gui.add(params, 'exposure', 0.1, 2).onChange(function (value) {
        renderer.toneMappingExposure = Math.pow(value, 4.0);
      });

      gui.add(params, 'bloomThreshold', 0.0, 1.0).onChange(function (value) {
        bloomPass.threshold = (value);
      });

      gui.add(params, 'bloomStrength', 0.0, 10.0).onChange(function (value) {

        bloomPass.strength = value;

      });

      gui.add(params, 'bloomRadius', 0.0, 1.0).onChange(function (value) {

        bloomPass.radius = (value);

      });
      gui.add(controls, 'showZhihuan').onChange(function (value) {
        zhihuanModel.visible = value;
      });

    }

    function loadGlb(url) {
      return new Promise((resolve, reject) => {
        var loader = new GLTFLoader();
        loader.load(url, (glb) => {
          console.log(glb);
          resolve(glb.scene);
        });
      });
    }


    function loadHDR(url, pmremGenerator) {
      return new Promise((resolve, reject) => {
        var loader = new RGBELoader();
        loader.setDataType(THREE.UnsignedByteType);
        loader.load(url, (texture) => {
          var envMap = pmremGenerator.fromEquirectangular(texture).texture;
          var equiToCube = new EquirectangularToCubemap( renderer, THREE );
          var cubeMap = equiToCube.convert( texture, 1024 ,THREE);
          resolve([envMap, cubeMap]);
        });
      });
    }

    function processModel(model, cubeTexture, refractTexture) {

      // const geometry = new THREE.SphereGeometry(0.05, 128, 128);
      // const material = new getBackMaterial(THREE, cubeTexture, refractTexture);
      // const sp = new THREE.Mesh(geometry, material);
      // model.getObjectByName("zuanshi").visible = false;;
      // scene.add(sp);
      // backModel = sp;


      backModel = model.getObjectByName("zuanshi");
      frontModel = backModel.clone(true);
      frontModel.name = "front_zuanshi";
      backModel.parent.add(frontModel);
      backModel.material = getBackMaterial(THREE, cubeTexture, refractTexture);
      console.log(frontModel);
      frontModel.material = getFrontMaterial(THREE, cubeTexture, refractTexture);
      zhihuanModel = model.getObjectByName("zhihuan");

      frontModel.layers.enable( BLOOM_SCENE );
      backModel.layers.enable( BLOOM_SCENE );
      zhihuanModel.layers.enable(NORMAL_SCENE);
    }

    init();
    AddGUI(params);

    var renderTarget = new THREE.WebGLRenderTarget(1024, 1024);

    async function init() {
      container = document.createElement('div');
      document.body.appendChild(container);
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 200);
      camera.position.set(0, 0, 0.5);
      scene = new THREE.Scene();
      // scene.background = new THREE.Color(0xffffff);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.debug.checkShaderErrors = false;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      // renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1;
      renderer.outputEncoding = THREE.sRGBEncoding;
      container.appendChild(renderer.domElement);
      var pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();
      controls = new OrbitControls(camera, renderer.domElement);
      controls.minDistance = 0.01;
      controls.maxDistance = 100;
      controls.target.set(0, 0, 0);
      controls.update();
      window.addEventListener('resize', onWindowResize, false);
      const hdr = await loadHDR('model/hdr/GlazedPatio.hdr', pmremGenerator);
      const model = await loadGlb('model/jiezhi/jiezhi.glb');
      scene.add(model);
      processModel(model, hdr[1], hdr[1]);
      console.log(model);

      scene.environment = hdr[0];
      //scene.background =  hdr[0];

      renderScene = new RenderPass(scene, camera);
      //renderScene.renderToScreen = true;

      bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      bloomPass.threshold = params.bloomThreshold;
      bloomPass.strength = params.bloomStrength;
      bloomPass.radius = params.bloomRadius;


      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      composer.renderToScreen = false;

      var finalPass = new ShaderPass(
        new THREE.ShaderMaterial({
          uniforms: {
            baseTexture: { value: null },
            bloomTexture: { value: composer.renderTarget2.texture }
          },
          vertexShader: document.getElementById('vertexshader').textContent,
          fragmentShader: document.getElementById('fragmentshader').textContent,
          defines: {}
        }), "baseTexture"
      );
      finalPass.needsSwap = true;
      finalComposer = new EffectComposer(renderer);
      finalComposer.addPass(renderScene);
      finalComposer.addPass(finalPass);
      animate();
    }




    function setModelUniformsV3(param, v3) {
      frontModel.material.uniforms[param].value[0] = v3.x;
      frontModel.material.uniforms[param].value[1] = v3.y;
      frontModel.material.uniforms[param].value[2] = v3.z;
      backModel.material.uniforms[param].value[0] = v3.x;
      backModel.material.uniforms[param].value[1] = v3.y;
      backModel.material.uniforms[param].value[2] = v3.z;
    }

    function setModelUniformsV1(param, v1) {
      frontModel.material.uniforms[param].value = v1;
      backModel.material.uniforms[param].value = v1;
    }

    function setModelUniformsC3(param, value) {
      frontModel.material.uniforms[param].value = new THREE.Vector3(value[0] / 255, value[1] / 255, value[2] / 255);
      backModel.material.uniforms[param].value = new THREE.Vector3(value[0] / 255, value[1] / 255, value[2] / 255);

    }


    function animate() {
      requestAnimationFrame(animate);
      //console.log(backMaterial);
      let mat = new THREE.Matrix4();
      let modlePos = new THREE.Vector3();
      modlePos.copy(camera.position);
      modlePos.applyMatrix4(mat.getInverse(backModel.matrixWorld));
      setModelUniformsV3("cameraWorldPos", modlePos);
      render();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    }

    function processNormalObject() {
      scene.traverse(darkenNonBloomed);
      composer.render();
      scene.traverse(restoreMaterial);
    }

    function darkenNonBloomed(obj) {
      if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
        materials[obj.uuid] = obj.material;
        obj.material = darkMaterial;
      }

    }

    function restoreMaterial(obj) {

      if (materials[obj.uuid]) {

        obj.material = materials[obj.uuid];
        delete materials[obj.uuid];

      }

    }

    function render() {
      processNormalObject();
      finalComposer.render();
    }

  </script>
</body>

</html>